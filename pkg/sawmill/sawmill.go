package sawmill

// If you're wondering why this package is named sawmill: https://clips.twitch.tv/PlacidOutstandingPelicanCharlieBitMe

import (
	"context"
	"log"
	"net/http"
	"os"
	"strconv"

	"cloud.google.com/go/errorreporting"
	"google.golang.org/api/option"
)

// Logger holds the newly generated error logging client, so that it can be used for our own, more simple custom logging functions instead of the ones the Google provides
type Logger struct {
	ErrorClient *errorreporting.Client // The client generated by Google

	// If their was an error with the initialization, InitError will be true, so when an error logging function is called, nothing will happen
	// If the initialization fails, it will just print the same error that we already log when the Client is initialized
	// Basically InitError just reduces log clutter
	InitError bool

	ServiceName string // The service that logging was created for
}

// InitClient accesses the enviroment variables on its own, and creates an error logging client
func InitClient(serviceName string) (Logger, error) {
	// Gets correct enviroment variable
	var currentProject string

	if os.Getenv("ENVIRONMENT") == "DEV" {
		currentProject = os.Getenv("FIREBASE_PROJECTID_DEV")
	} else if os.Getenv("ENVIRONMENT") == "PROD" {
		currentProject = os.Getenv("FIREBASE_PROJECTID_PROD")
	}

	ctx := context.Background()

	// Initializes an Google logging client
	errorClient, err := errorreporting.NewClient(ctx, currentProject, errorreporting.Config{
		ServiceName: serviceName,
		// This is called on a logging error
		OnError: func(err error) {
			log.Printf("Logging error in "+serviceName+": %v", err)
		},
	}, option.WithCredentialsFile(os.Getenv("GOOGLE_APPLICATION_CREDENTIALS")))
	if err != nil {
		// If there is an error with initialization, it returns a Client object containing an empty ErrorClient, and sets WasError to be true, so nothing gets reported, which would trigger an error message
		return Logger{nil, true, ""}, err
	}

	// If there wasn't an error, it returns a Client object with an ErrorClient, and sets WasError to be false
	return Logger{errorClient, false, serviceName}, nil
}

// LogErr logs an error with Google Cloud
func (c Logger) LogErr(err error, operation string, optionalArgs ...interface{}) {
	// Checks if there was an error with initialization

	if len(optionalArgs) > 2 {
		log.Print("Logging warning in " + c.ServiceName + ": too many arguments")
	}

	log.Printf(c.ServiceName+" ["+operation+"]: %v", err)

	if c.InitError {
		return
	}

	var req *http.Request
	var user string

	for i := range optionalArgs {
		switch optionalArgs[i].(type) {
		case *http.Request:
			req = optionalArgs[i].(*http.Request)

		case string:
			user = optionalArgs[i].(string)

		case int:
			user = strconv.Itoa(optionalArgs[i].(int))
		}
	}

	// Reports the error
	c.ErrorClient.Report(errorreporting.Entry{
		Error: err,
		Req:   req,
		User:  user,
	})

	// As every single error log is followed by a return statement, no more errors get logged after the first, so we close the client
	c.ErrorClient.Close()
}
